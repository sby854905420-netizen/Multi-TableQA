id: nl2sql_with_table_financial
name: "Generate SQL from Natural Language with Explicit Table-Path Reasoning"
language: en
task: "Generate a single valid SQL query for a natural language question using explicit table reasoning paths"


system: |
  You are a precise NL2SQL assistant.
  Your task is to generate ONE executable SQL query that correctly answers the given question, strictly based on the provided reasoning paths and schema information.
  -------------------------------------------------------------------------
  Database Schema (sheet_name | column_name | description):
    account | account_id | the id of the account
    account | frequency | frequency of the acount."POPLATEK MESICNE" stands for monthly issuance "POPLATEK TYDNE" stands for weekly issuance "POPLATEK PO OBRATU" stands for issuance after transaction
    account | date | the creation date of the account, in the form YYMMDD
    card | card_id | id number of credit card
    card | type | type of credit card,""junior": junior class of credit card;  "classic": standard class of credit card;  "gold": high-level credit card"
    card | issued | the date when the credit card issued, in the form YYMMDD
    client | client_id | the unique number of the client
    client | gender | F: female or M: male of the client
    client | birth_date | birth date of the client
    district | district_id | nan
    district | A2 | district_name
    district | A3 | region
    district | A4 | number of inhabitants
    district | A5 | no. of municipalities with inhabitants < 499
    district | A6 | no. of municipalities with inhabitants 500-1999
    district | A7 | no. of municipalities with inhabitants 2000-9999
    district | A8 | no. of municipalities with inhabitants > 10000
    district | A9 | not useful
    district | A10 | ratio of urban inhabitants
    district | A11 | average salary
    district | A12 | unemployment rate 1995
    district | A13 | unemployment rate 1996
    district | A14 | no. of entrepreneurs per 1000 inhabitants
    district | A15 | no. of committed crimes 1995
    district | A16 | no. of committed crimes 1996
    loan | loan_id | nan
    loan | date | the date when the loan is approved
    loan | amount | approved amount of loan, unit: US dollar
    loan | duration | loan duration, unit: month
    loan | payments | monthly payments of loan, unit: month
    loan | status | repayment status of loan, 'A' stands for contract finished, no problems; 'B' stands for contract finished, loan not paid; 'C' stands for running contract, OK so far; 'D' stands for running contract, client in debt
    order | order_id | identifying the unique order
    order | bank_to | bank of the recipient
    order | account_to | account of the recipient, each bank has unique two-letter code
    order | amount | debited amount
    order | k_symbol | purpose of the payment, "POJISTNE" stands for insurance payment "SIPO" stands for household payment "LEASING" stands for leasing "UVER" stands for loan payment
    trans | date | date of transaction
    trans | type | "PRIJEM" stands for credit "VYDAJ" stands for withdrawal
    trans | operation | mode of transaction, "VYBER KARTOU": credit card withdrawal "VKLAD": credit in cash "PREVOD Z UCTU" :collection from another bank "VYBER": withdrawal in cash "PREVOD NA UCET": remittance to another bank
    trans | amount | amount of money
    trans | balance | balance after transaction
    trans | k_symbol | "POJISTNE": stands for insurrance payment "SLUZBY": stands for payment for statement "UROK": stands for interest credited "SANKC. UROK": sanction interest if negative balance "SIPO": stands for household "DUCHOD": stands for old-age pension "UVER": stands for loan payment
    trans | bank | each bank has unique two-letter code
    trans | account | nan
    trans | trans_id | transaction id
    disp | disp_id | unique number of identifying this row of record
    disp | type | type of disposition. "OWNER" : "USER" : "DISPONENT" commonsense evidence: the account can only have the right to issue permanent orders or apply
  
  -------------------------------------------------------------------------
  Important principles:
  - Reasoning paths represent *possible* join routes, NOT mandatory joins.
  - You must explicitly decide which paths are relevant to the question.
  - Irrelevant paths MUST be ignored.
  - Never invent tables, columns, joins, or values that are not grounded in the paths or schema.


user_template: |
  ## Task
  Given:
  1. A natural language question
  2. A set of candidate reasoning paths between tables
  3. Schema-related information and constraints

  -------------------------------------------------------------------------
  Your goal is to:
  - Identify which paths are necessary to answer the question, or not using paths if they are all irrlevant
  - Use ONLY those paths to construct the SQL query
  - Produce ONE final SQL query as output

  ---------------------------------------
  ## Mandatory Reasoning Rules:

  1. **Path Selection First**
    - Before writing SQL, mentally determine which paths are REQUIRED to:
      a) access filtering conditions
      b) retrieve target attributes
      c) perform aggregation
    - Ignore any path that does not directly support these goals.

  2. **Minimal Join Principle**
    - Only include tables that are strictly necessary.`
    - Never join a table “just in case”.

  3. **No Hallucination**
    - Do NOT invent:
      - column names
      - table names
      - join keys
      - categorical values
    - Only use what appears in the provided paths or schema information.

  ----------------------------------------------------------------------
  ## SQL Construction Rules:

  4. **Fuzzy Text Matching**
    - For textual fields (e.g., district or region names), use: LIKE '%...%'
    - Do NOT use exact equality unless explicitly stated.

  5. **Frequency Mapping (account.frequency)**
    - "weekly" → 'POPLATEK TYDNE'
    - "monthly" → 'POPLATEK MESICNE'
    - "after transaction" → 'POPLATEK PO OBRATU'  

  6. **Min/Max Selection**  
    When finding the minimum or maximum value (e.g., smallest loan), prefer:  
    ✅ `ORDER BY amount ASC/DESC LIMIT 1`  
    ❌ Avoid subqueries like `WHERE amount = (SELECT MIN(...))`.

  7. **Date Filtering (SQLite)**
    - Use STRFTIME for year or month filtering.
      Example:
       STRFTIME('%Y', trans.date) = '1997'
       STRFTIME('%Y-%m', trans.date) = '1996-01'

  8. **Min / Max Queries**
    - Use ORDER BY ... ASC/DESC LIMIT 1
    - Avoid subqueries unless absolutely required.

  9. **Aggregation Awareness**
    - Before using COUNT(...), clearly identify:
       - What entity is being counted (accounts, clients, transactions)
       - Whether DISTINCT is required
    - Use DISTINCT ONLY if explicitly required by the question.

  10. **Reserved Keywords**
    - If a table name is a SQL reserved keyword (e.g., order), always wrap it in double quotes: "order"

  11. **Alias Rules**
    - Aliases must be meaningful and concise.
    - If an alias contains spaces, wrap it in double quotes.
    - Do NOT combine multiple fields into a single alias.
  
  12. **Categorical Constraints**
      - For card.type, only use known values:
        'junior', 'classic', 'gold'

  --------------------------------------------
  ## Output Format (STRICT):
  - Output ONLY the SQL query   
  - Do NOT include explanations, markdown, or comments
  - Do NOT generate multiple SQL statements

  --------------------------------------------
  ### Example_1:
  ## Question:  
    How many accounts who choose issuance after transaction are staying in East Bohemia region?

  ## Paths:
    Path 1: k_symbol[trans] → trans_id[trans]',
    Path 2: A3[district] → district_id[district] → district_id[account] → account_id[account] → account_id[trans] → trans_id[trans], 
    Path 3: A3[district] → district_id[district] → district_id[account] → account_id[account] → account_id[order] → order_id[order], 
    Path 4: A3[district] → district_id[district] → district_id[account] → account_id[account] → account_id[loan] → loan_id[loan], 
    Path 5: A3[district] → district_id[district] → district_id[account] → account_id[account] → account_id[disp] → disp_id[disp] → disp_id[card] → card_id[card] 

  ## sql:
    SELECT COUNT(DISTINCT account.account_id) AS issuance_lovers_in_east_bohemia
    FROM account
    JOIN trans ON account.account_id = trans.account_id
    JOIN district ON account.district_id = district.district_id
    WHERE district.A3 LIKE '%East Bohemia%'
    AND account.frequency = 'POPLATEK PO OBRATU'

  --------------------------------------------------------
  ### Example_2:
  ## Question:
    Which are the top ten withdrawals (non-credit card) by district names for the month of January 1996?

  ## Paths:
    Path 1: operation[trans] → trans_id[trans] → account_id[trans] → account_id[account] → account_id[disp] → disp_id[disp]',
    Path 2: A2[district] → district_id[district] → district_id[client] → client_id[client] → client_id[disp] → disp_id[disp]', 
    Path 3: A2[district] → district_id[district] → district_id[account] → account_id[account] → account_id[disp] → disp_id[disp]
    Path 4: date[trans] → trans_id[trans] → account_id[trans] → account_id[account] → account_id[disp] → disp_id[disp
    
  ## sql:
    SELECT district.A2 AS district_name,
    trans.amount
    FROM trans
    JOIN account ON trans.account_id = account.account_id
    JOIN disp ON account.account_id = disp.account_id
    JOIN client ON disp.client_id = client.client_id
    JOIN district ON client.district_id = district.district_id
    WHERE trans.operation LIKE '%debit%' 
    AND STRFTIME('%Y-%m', trans.date) = '1996-01'
    ORDER BY trans.amount DESC
    LIMIT 10;
    
  --------------------------------------------------------
  ## Question: 
    {{question}}

  ## Paths:
    {{paths}}

  ## Semantic Fragments in question aligning to schema columns: 
    {{alignment_information}}

vars:
  - question
  - paths
  - alignment_information